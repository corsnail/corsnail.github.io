<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://corsnail.github.io/atom.xml" rel="self"/>
  
  <link href="https://corsnail.github.io/"/>
  <updated>2024-04-24T10:18:50.036Z</updated>
  <id>https://corsnail.github.io/</id>
  
  <author>
    <name>snail</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>paluctf wp</title>
    <link href="https://corsnail.github.io/2024/04/24/paluctf/"/>
    <id>https://corsnail.github.io/2024/04/24/paluctf/</id>
    <published>2024-04-24T10:15:24.000Z</published>
    <updated>2024-04-24T10:18:50.036Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些不会的或者比赛会用到的</p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="FM-145-8"><a href="#FM-145-8" class="headerlink" title="FM 145.8"></a>FM 145.8</h2><blockquote><p><a href="https://blog.csdn.net/qq_51652400/article/details/123504708">参考这篇博客</a></p></blockquote><blockquote><p>SSTV<br>慢扫描电视（Slow-scan television 简称 SSTV）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。  </p><p>表示这玩意真的出烂了，傻瓜式操作</p></blockquote><p><strong>使用工具：MMSSTV，e2eSoft</strong><br><strong>文件类型：wav</strong><br>工具上就完了</p><p>e2esoft (VSC)是一个虚拟声卡工具，理解一下简单说就是选择一下输入输出设备让他转换一下</p><p>首先将声音输出到虚拟声卡<br><img src="/images/article/20240424/Pasted%20image%2020240422143330.png"></p><p>然后在电脑的音频输出的地方选择<br><img src="/images/article/20240424/Pasted%20image%2020240422143615.png"><br>然后直接 MMSSTV 播放就可以出 flag 了<br><img src="/images/article/20240424/Pasted%20image%2020240422143544.png"><br>公式化做题</p><h2 id="为什么我的新猫猫吃不饱"><a href="#为什么我的新猫猫吃不饱" class="headerlink" title="为什么我的新猫猫吃不饱"></a>为什么我的新猫猫吃不饱</h2><p>打开有一张图片 (png)，一张 gif<br>首先这里用 010 看 gif<br><img src="/images/article/20240424/Pasted%20image%2020240422150825.png"><br>看见一个很像 flag 的内容，注意不要把 HHT5 带进去了，flag 不包含这部分，然后随波逐流一把梭<br><img src="/images/article/20240424/Pasted%20image%2020240422150959.png"><br>flag{my_ca1_<br>然后来看另外一张图片 png 左边有一条竖的线，要么是 lsb，要么是盲水印<br>这里我把 gif 切割为一帧一帧（puzzlesolver 工具或者 conver 1. gif 1. png 都可以）<br>发现第 22 张图片很像<br>puzzlesolver<br><img src="/images/article/20240424/Pasted%20image%2020240422152001.png"><br><img src="/images/article/20240424/Mycatisreallyhungry.png_FBwm.png"><br>（不知道为什么复现变成这样了，之前和官方出题人那个很像）<br>flag{my_ca1_1s_Fu11}</p><h2 id="350x350"><a href="#350x350" class="headerlink" title="350x350"></a>350x350</h2><p>比较简单，但是比较套，前面就不停的 binwalk 分析，binwalk -e 切割（或者 foremost 切割），多试一试几条命令，换几个平台，因为总有 bug<br>讲讲最后拿到只剩下两张图片<br><img src="/images/article/20240424/Pasted%20image%2020240422152627.png"><br>这里也可以看到我试了很多次<br>最后的最后，会用到下面这个项目</p><p><a href="https://github.com/guofei9987/blind_watermark?tab=readme-ov-file">https://github.com/guofei9987/blind_watermark?tab=readme-ov-file</a><br>这个项目中水印可以是三种东西，文字、图片和二进制数据（其实你想，可以变成很多种东西）</p><p>这里的 3. png 是原图，33. png 是带水印的图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from blind_watermark import WaterMark</span><br><span class="line"></span><br><span class="line">bwm1 = WaterMark(password_wm=1, password_img=1)</span><br><span class="line"># notice that wm_shape is necessary</span><br><span class="line">bwm1.extract(filename=&#x27;33.png&#x27;, wm_shape=(350, 350), out_wm_name=&#x27;extracted33.png&#x27;, )</span><br></pre></td></tr></table></figure><p>会导出一张二维码，扫描二维码得到数据<br><img src="/images/article/20240424/extracted33.png"><br><code>flag&#123;b3bd61023d129f9e39b4a26b98c0f366&#125;</code></p><h2 id="ez-misc"><a href="#ez-misc" class="headerlink" title="ez_misc"></a>ez_misc</h2><p>binwalk 切割出一个图片，010 打开最后有一个很明显的编码要么是零宽隐写要么是snow<br><img src="/images/article/20240424/Pasted%20image%2020240422154745.png"></p><blockquote><p>snow 隐写内容<br><img src="/images/article/20240424/Pasted%20image%2020240422203348.png"></p></blockquote><p>这里只需要将提取内容拿出来然后保存为 1. txt，然后直接用工具解出就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snow -C 1.txt</span><br></pre></td></tr></table></figure><p><img src="/images/article/20240424/Pasted%20image%2020240422203941.png"><br><code>Carefree and carefree</code><br>应该是压缩包密码<br>但是我这里还有伪加密<br><img src="/images/article/20240424/Pasted%20image%2020240422205120.png"></p><blockquote><p>压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志<br><strong>压缩源文件数据区</strong>：<br>50 4B 03 04：这是头文件标记（0x04034b50）<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>00 00：扩展记录长度</p><p><strong>压缩源文件目录区</strong>：<br>50 4B 01 02：目录中文件文件头标记(0x02014b50)<br>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量</p><p><strong>压缩源文件目录结束标志</strong>：<br>50 4B 05 06：目录结束标记<br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>59 00 00 00：目录区尺寸大小<br>3E 00 00 00：目录区对第一张磁盘的偏移量<br>00 00：ZIP 文件注释长度</p></blockquote><p>简单来说就是一个压缩包肯定会有上面的内容，伪加密就是本来这个 zip 没有压缩，但是我修改了标志位，然后计算机就以为它压缩了，我们只需要把这些标志位修改为 00 00</p><p>这道题目这里是压缩源文件目录区（可以根据文件头标志匹配）<br><img src="/images/article/20240424/Pasted%20image%2020240422210727.png"><br>这里的全局方式位标记为 09 00，修改为 00 00 即可<br>解压之后使用上面的密码即可拿到flag<br><img src="/images/article/20240424/Pasted%20image%2020240422210900.png"><br><code>flag&#123;b220116fc6ca827ecf3cb6c6c06dac26&#125;</code></p><h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><h2 id="Pylu"><a href="#Pylu" class="headerlink" title="Pylu"></a>Pylu</h2><p>pyinstxtractor 解包<br>pycdc 反编译出来<br>然后发现竟然是个密码题</p><p>尝试用 z3 爆破<br>但是觉得可能性不大，所以只爆了 1min 就结束了<br>赛后看 wp，就是用 z3 爆破的，可恶</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> z3</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">key</span>):</span><br><span class="line">    R = bytes_to_long(<span class="string">b&quot;Welcome To PaluCTF!&quot;</span>)</span><br><span class="line">    MOD = <span class="number">2</span>**<span class="number">418</span></span><br><span class="line">    R = R ^ (R - <span class="number">60</span>) &gt;&gt; <span class="number">24</span></span><br><span class="line">    R = R ^ (R - <span class="number">60</span>) &lt;&lt; <span class="number">88</span></span><br><span class="line"></span><br><span class="line">    R ^= key</span><br><span class="line">    R = (-R * R * <span class="number">2024</span>) % MOD  </span><br><span class="line">    R = (R * key) % MOD</span><br><span class="line">    <span class="keyword">return</span> R</span><br><span class="line"></span><br><span class="line">cor = <span class="number">0x2E441F765514CCA89173554726494D37E9FBE774B6F807BC5F6E71117530CE3D7DB5F70554C03CD9055F4E42969600904DF1F4DB8</span></span><br><span class="line">s = z3.Solver()</span><br><span class="line">key = z3.BitVec(<span class="string">&quot;key&quot;</span>, <span class="number">418</span>)</span><br><span class="line">s.add(enc(key)==cor)</span><br><span class="line">s.check()</span><br><span class="line">m = s.model()</span><br><span class="line">flag = long_to_bytes(m[key].as_long())</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="茶"><a href="#茶" class="headerlink" title="茶"></a>茶</h2><p>判断是 chacha2.0<br><img src="/images/article/20240424/Pasted%20image%2020240424165943.png"><br>然后简单看看 enc 和 key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enc = &quot;f568c48912eed6dc520c7164f44b6378e1d0d3e248914fa8847b405a131f&quot;</span><br><span class="line">key = &quot;SGludDogSW1wcm92ZSBvZiBTYWxzYTIw&quot;</span><br><span class="line"></span><br><span class="line">&quot;Is_This_TEA?&quot;</span><br></pre></td></tr></table></figure><p>动调过程中发现去掉了最后四字节<br>借鉴脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ChaCha20</span><br><span class="line"></span><br><span class="line">enc_data = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;f568c48912eed6dc520c7164f44b6378e1d0d3e248914fa8847b405a131f&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = <span class="string">b&quot;SGludDogSW1wcm92ZSBvZiBTYWxzYTIw&quot;</span></span><br><span class="line">nonce = <span class="string">b&quot;Is_This_&quot;</span></span><br><span class="line"></span><br><span class="line">cc = ChaCha20.new(key=key, nonce=nonce)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cc.decrypt(enc_data))</span><br></pre></td></tr></table></figure><p>flag{But_I_Like_ChaCha20_More}</p><h2 id="O2"><a href="#O2" class="headerlink" title="O2"></a>O2</h2><p><img src="/images/article/20240424/Pasted%20image%2020240423165239.png"><br>查壳</p><p>直接用 ida 打开错误<br>用 010 打开跑一下模板</p><p><img src="/images/article/20240424/Pasted%20image%2020240423165343.png"><br>这个地方是用来判断 elf 的位数的，ctf 常考点，尝试修改<br>1是32位，2是64位<br>现在改为 02 然后导出副本，发现是可以的</p><p><img src="/images/article/20240424/Pasted%20image%2020240423175246.png">用 ida 打开<br><img src="/images/article/20240424/Pasted%20image%2020240424110500.png"><br>定位到关键函数 enc<br>对三个参数进行分析，发现第三个参数是 key（PaluCTF）<br>那么第一个参数就是 output，加密后的 flag</p><blockquote><p>!注意!：这里的变量需要动态调试的时候才会加载进去</p></blockquote><p>这里差不多，加密逻辑清晰，ouput 最后要与 obj 比较，也就是说</p><p>已知：<br>加密逻辑，输出密文，key 那么我们就可以求出 flag 了<br>这里还是爆破比较好，因为加密比较难看</p><p>借鉴的 wp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> printable</span><br><span class="line"></span><br><span class="line">enc = <span class="built_in">bytearray</span>.fromhex(<span class="string">&quot;364d4d5c3e387e00421c597a0a7302144d5b70087e064619567336297d151f56770a7935424f2a780643&quot;</span>)</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;PaluCTF&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> printable:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ord</span>(c) + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">128</span> == enc[i]:</span><br><span class="line">            <span class="built_in">print</span>(c, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>flag{d80a0d76-23af-486e-a0bc-43a463eac552}<br>另外一篇博客 z3 求解的时候会用 z3 求一遍</p><p>参考：<br><a href="https://www.yuque.com/yuro/rueylp/hu91xww3olyp8h04#PpXM8">帕鲁杯 Writeup</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一些不会的或者比赛会用到的&lt;/p&gt;
&lt;h1 id=&quot;Misc&quot;&gt;&lt;a href=&quot;#Misc&quot; class=&quot;headerlink&quot; title=&quot;Misc&quot;&gt;&lt;/a&gt;Misc&lt;/h1&gt;&lt;h2 id=&quot;FM-145-8&quot;&gt;&lt;a href=&quot;#FM-145-8&quot; clas</summary>
      
    
    
    
    <category term="wp" scheme="https://corsnail.github.io/categories/wp/"/>
    
    
    <category term="CTF" scheme="https://corsnail.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>pikachu之暴力破解</title>
    <link href="https://corsnail.github.io/2024/04/19/pikachu%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <id>https://corsnail.github.io/2024/04/19/pikachu%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</id>
    <published>2024-04-19T07:15:24.000Z</published>
    <updated>2024-04-19T07:17:40.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h1><p><img src="/images/article/20240419/Pasted%20image%2020240415142706.png"><br>bp 抓包放入爆破器<br><img src="/images/article/20240419/Pasted%20image%2020240415143035.png"><br>选择交叉爆破<br><img src="/images/article/20240419/Pasted%20image%2020240415142926.png"><br>分别都导入字典，然后 start attack<br><img src="/images/article/20240419/Pasted%20image%2020240415143128.png"><br>爆出来三组账号密码<br>admin 123456<br>test abc123<br>pikachu 000000<br>当然这里字典是针对性加的</p><h1 id="验证码绕过（on-server）"><a href="#验证码绕过（on-server）" class="headerlink" title="验证码绕过（on server）"></a>验证码绕过（on server）</h1><p>这种服务器后台不刷新验证码，只要抓包后不放包就可以一直用<br>抓包看看<br><img src="/images/article/20240419/Pasted%20image%2020240415143708.png"><br>抓包带上验证码，试试爆破<br><img src="/images/article/20240419/Pasted%20image%2020240415143733.png"><br>配置啥的和上面一样都是交叉爆破<br><img src="/images/article/20240419/Pasted%20image%2020240415143755.png"><br>最后同样爆破出来的，这里是因为验证码不变，可以无限复用</p><h1 id="验证码绕过（on-client）"><a href="#验证码绕过（on-client）" class="headerlink" title="验证码绕过（on client）"></a>验证码绕过（on client）</h1><p>这里和上面一样，也是用验证码直接爆破就行<br><img src="/images/article/20240419/Pasted%20image%2020240415144806.png"><br>这里的不同是将验证码的生成规则直接写在了前端<br><img src="/images/article/20240419/Pasted%20image%2020240415145155.png"><br>当然这里使用随机数实现的验证码，如果是基于时间戳之类的还可以用 python 脚本发包来爆破</p><h1 id="token-防爆破"><a href="#token-防爆破" class="headerlink" title="token 防爆破"></a>token 防爆破</h1><p>这里加入了 token，也是一种校验用的东西，带上它，就可以一定程度上防止爆破</p><blockquote><p>简单来说 token 就是服务器给客户端发的身份证，客户端发请求时要带上这个身份证，不然就是不合法请求</p></blockquote><p><img src="/images/article/20240419/Pasted%20image%2020240415145629.png"><br>这里我们再用相同的方法去爆破，可以看到提示 token 失败<br><img src="/images/article/20240419/Pasted%20image%2020240415152021.png"></p><p>带上 token 爆破<br><img src="/images/article/20240419/Pasted%20image%2020240415153704.png"><br>这里像这样单线程跑整个爆破<br><img src="/images/article/20240419/Pasted%20image%2020240415153841.png"><br>然后加一个 grep，点击add<br><img src="/images/article/20240419/Pasted%20image%2020240415153914.png"><br>点击 refetch，然后搜索token<br><img src="/images/article/20240419/Pasted%20image%2020240415153959.png"><br>选中 value 所指的值，然后点击 ok<br><img src="/images/article/20240419/Pasted%20image%2020240415155407.png"><br>然后回到 payload 中，选择 3，然后 payload 类型选择从 grep 中获取，然后填入第一个 token<br><img src="/images/article/20240419/Pasted%20image%2020240415151252.png"><br>效率很慢，但是这里的 root root 的时候会提示账号密码不存在，也就是说 token 是生效的<br>突然想起来，这里爆破类型选择了这个<br><img src="/images/article/20240419/Pasted%20image%2020240415154232.png"><br>简单理解一下，假如有两个等待爆破的参数<br>他们的字典都是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">admin</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p>Cluster bomb 的爆破就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| root  | root   |</span><br><span class="line">| root  | admin  |</span><br><span class="line">| root  | 123456 |</span><br><span class="line">| admin | root   |</span><br><span class="line">| admin | admin  |</span><br><span class="line">| admin | 123456 |</span><br></pre></td></tr></table></figure><p>Pitchfork 则是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| root  | root   |</span><br><span class="line">| admin | admin  |</span><br><span class="line">| 123456 | 123456 |</span><br></pre></td></tr></table></figure><p>所以这里应该选择 Pitchfork<br><img src="/images/article/20240419/Pasted%20image%2020240415155547.png"><br>同时我这里减少爆破项，减少爆破时间<br><img src="/images/article/20240419/Pasted%20image%2020240415155640.png"><br>得到 admin 的密码 123456</p><p>参考文章：<br><a href="https://blog.csdn.net/weixin_39190897/article/details/86539542">渗透测试-验证码的爆破与绕过</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于表单的暴力破解&quot;&gt;&lt;a href=&quot;#基于表单的暴力破解&quot; class=&quot;headerlink&quot; title=&quot;基于表单的暴力破解&quot;&gt;&lt;/a&gt;基于表单的暴力破解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/article/20240419/Pasted%</summary>
      
    
    
    
    <category term="web" scheme="https://corsnail.github.io/categories/web/"/>
    
    
    <category term="pikachu" scheme="https://corsnail.github.io/tags/pikachu/"/>
    
  </entry>
  
  <entry>
    <title>VenomCTF REWP</title>
    <link href="https://corsnail.github.io/2024/03/21/VenomCTFWP/"/>
    <id>https://corsnail.github.io/2024/03/21/VenomCTFWP/</id>
    <published>2024-03-21T10:47:17.000Z</published>
    <updated>2024-03-27T04:31:32.929Z</updated>
    
    <content type="html"><![CDATA[<p>这是某团队的招新赛总体难度还是不大的，这里写一下RE一道题目的WP</p><h1 id="ezre"><a href="#ezre" class="headerlink" title="ezre"></a>ezre</h1><p>一道简单题，总结就是换表base64，变异RC4</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="/images/article/20240326/image-20240326222723.png"><br>很简单的逻辑</p><p><img src="/images/article/20240326/image-20240326222754.png"><br>第一个函数对key进行处理，由于对key处理的各种参数都是明文的，所以我们可以在这里下断点获取处理之后的key。</p><p><img src="/images/article/20240326/image-20240327101130.png"><br>第二个函数对flag操作，将flag与一个变换后的key进行操作，由于变换的key比较复杂，同时变换的key同样与我们输入的参数无关，只需要使用原来的c代码就可以获取</p><p><img src="/images/article/20240326/image-20240326223252.png"><br><img src="/images/article/20240326/image-20240326223313.png"><br>第三个函数对flag最后处理，有个很明显的码表，大概能猜到是base64，仔细看看也能确定是base64。</p><h2 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h2><p><img src="/images/article/20240326/image-20240327104435.png"><br>下断点拿到key的值</p><p>通过脚本拿到xor_key的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#define HIDWORD(x) ((uint32_t)(((uint64_t)(x) &gt;&gt; 32) &amp; 0xFFFFFFFF))</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int v6; // [rsp+24h] [rbp-14h]</span><br><span class="line">    int v7; // [rsp+28h] [rbp-10h]</span><br><span class="line">    unsigned __int64 i; // [rsp+30h] [rbp-8h]</span><br><span class="line">    int v3;</span><br><span class="line">    int v5;</span><br><span class="line">    int len = 21;</span><br><span class="line"></span><br><span class="line">    v6 = 0;</span><br><span class="line">    v7 = 0;</span><br><span class="line">    unsigned char key[128] = &#123;</span><br><span class="line">            0x54, 0x0D, 0x08, 0x60, 0x14, 0x2C, 0x41, 0x2A, 0x30, 0x2E, 0x1C, 0x66, 0x1B, 0x47, 0x32, 0x74,</span><br><span class="line">            0x65, 0x05, 0x68, 0x7E, 0x23, 0x24, 0x52, 0x5C, 0x48, 0x71, 0x11, 0x21, 0x25, 0x04, 0x3E, 0x4D,</span><br><span class="line">            0x5B, 0x4C, 0x17, 0x29, 0x78, 0x45, 0x00, 0x3C, 0x7B, 0x6B, 0x6A, 0x5A, 0x50, 0x61, 0x19, 0x15,</span><br><span class="line">            0x73, 0x7D, 0x75, 0x43, 0x3D, 0x3A, 0x70, 0x16, 0x77, 0x0C, 0x67, 0x51, 0x6F, 0x03, 0x6D, 0x58,</span><br><span class="line">            0x4E, 0x37, 0x12, 0x2D, 0x4A, 0x1A, 0x4F, 0x5F, 0x4B, 0x7C, 0x55, 0x0F, 0x1D, 0x0E, 0x31, 0x6E,</span><br><span class="line">            0x79, 0x1E, 0x22, 0x36, 0x69, 0x7A, 0x28, 0x26, 0x53, 0x56, 0x0B, 0x63, 0x5E, 0x64, 0x72, 0x3B,</span><br><span class="line">            0x5D, 0x0A, 0x42, 0x01, 0x2F, 0x13, 0x09, 0x46, 0x3F, 0x6C, 0x7F, 0x44, 0x1F, 0x34, 0x18, 0x57,</span><br><span class="line">            0x20, 0x39, 0x38, 0x02, 0x76, 0x10, 0x59, 0x49, 0x07, 0x27, 0x40, 0x2B, 0x35, 0x33, 0x62,0x06</span><br><span class="line">    &#125;;</span><br><span class="line">    for ( i = 0LL; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        if ( i &gt;= len )</span><br><span class="line">            break;</span><br><span class="line">        v6 = (v6 + 1) % 128;</span><br><span class="line">        v3 = *(v6 + key) + v7;                      // v3 = key[v6] + v7</span><br><span class="line">        v7 = (((HIDWORD(v3) &gt;&gt; 25) + *(v6 + key) + v7) &amp; 0x7F) - (HIDWORD(v3) &gt;&gt; 25);</span><br><span class="line">        v5 = *(v6 + key);                           // v5 = key[v6]</span><br><span class="line">        *(v6 + key) = *(v7 + key);                  // key[v6] = key[v7]</span><br><span class="line">        *(key + v7) = v5;                           // key[v7] = v5</span><br><span class="line">        printf(&quot;%d,&quot;,*(((*(v6 + key) + *(v7 + key)) &amp; 0x7F) + key));// flag[i] ^= key[(key[v6] + key[v7]) &amp; 0x7f]</span><br><span class="line">    &#125;     // key[v7] = v5</span><br><span class="line">&#125;</span><br><span class="line">//105,80,32,18,9,17,58,107,45,32,87,66,88,25,63,99,80,56,12,95,94,</span><br></pre></td></tr></table></figure><p>编写python脚本解密即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">key = [0x54, 0x0D, 0x08, 0x60, 0x14, 0x2C, 0x41, 0x2A, 0x30, 0x2E, 0x1C, 0x66, 0x1B, 0x47, 0x32, 0x74, 0x65, 0x05, 0x68, 0x7E, 0x23, 0x24, 0x52, 0x5C, 0x48, 0x71, 0x11, 0x21, 0x25, 0x04, 0x3E, 0x4D, 0x5B, 0x4C, 0x17, 0x29, 0x78, 0x45, 0x00, 0x3C, 0x7B, 0x6B, 0x6A, 0x5A, 0x50, 0x61, 0x19, 0x15, 0x73, 0x7D, 0x75, 0x43, 0x3D, 0x3A, 0x70, 0x16, 0x77, 0x0C, 0x67, 0x51, 0x6F, 0x03, 0x6D, 0x58, 0x4E, 0x37, 0x12, 0x2D, 0x4A, 0x1A, 0x4F, 0x5F, 0x4B, 0x7C, 0x55, 0x0F, 0x1D, 0x0E, 0x31, 0x6E, 0x79, 0x1E, 0x22, 0x36, 0x69, 0x7A, 0x28, 0x26, 0x53, 0x56, 0x0B, 0x63, 0x5E, 0x64, 0x72, 0x3B, 0x5D, 0x0A, 0x42, 0x01, 0x2F, 0x13, 0x09, 0x46, 0x3F, 0x6C, 0x7F, 0x44, 0x1F, 0x34, 0x18, 0x57, 0x20, 0x39, 0x38, 0x02, 0x76, 0x10, 0x59, 0x49, 0x07, 0x27, 0x40, 0x2B, 0x35, 0x33, 0x62, 0x06]</span><br><span class="line"></span><br><span class="line">enc_flag = &quot;3pn1Ek92hmAEg38EXMn99J9YBf8=&quot;</span><br><span class="line">string1 = &quot;0123456789XYZabcdefghijklABCDEFGHIJKLMNOPQRSTUVWmnopqrstuvwxyz+/=&quot;</span><br><span class="line">string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span><br><span class="line">enc_flag1 = base64.b64decode(enc_flag.translate(str.maketrans(string1,string2))) #string1码表替换string2</span><br><span class="line"></span><br><span class="line">xor_key = [105,80,32,18,9,17,58,107,45,32,87,66,88,25,63,99,80,56,12,95,94,]</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">for i in range(1,20):</span><br><span class="line">    flag += chr(enc_flag1[i]^xor_key[i])</span><br><span class="line"></span><br><span class="line">print(flag)</span><br><span class="line">//lag&#123;Simple_rEvErse&#125;</span><br></pre></td></tr></table></figure><p>得到结果可能是数据缺失，得到结果即可，仔细看其实是RC4算法，过程中灵活运用来减少时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是某团队的招新赛总体难度还是不大的，这里写一下RE一道题目的WP&lt;/p&gt;
&lt;h1 id=&quot;ezre&quot;&gt;&lt;a href=&quot;#ezre&quot; class=&quot;headerlink&quot; title=&quot;ezre&quot;&gt;&lt;/a&gt;ezre&lt;/h1&gt;&lt;p&gt;一道简单题，总结就是换表base64，变异</summary>
      
    
    
    
    <category term="wp" scheme="https://corsnail.github.io/categories/wp/"/>
    
    
    <category term="CTF" scheme="https://corsnail.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>z3求解器的简单使用</title>
    <link href="https://corsnail.github.io/2023/11/07/z3%E6%B1%82%E8%A7%A3%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://corsnail.github.io/2023/11/07/z3%E6%B1%82%E8%A7%A3%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-07T02:42:02.000Z</published>
    <updated>2023-11-07T08:39:04.225Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇见简单的逆向题用z3求解器简单求过，但是没有仔细学习过，这次又遇到一道逆向题，听说z3爆破很有作用</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Int           #整型</span><br><span class="line">Bool          #布尔型</span><br><span class="line">Real          #实数</span><br><span class="line">Array         #数组</span><br><span class="line">BitVec(&#x27;a&#x27;,8) #char型</span><br></pre></td></tr></table></figure><p>其中BitVec是一个比较灵活的数据结构，他可以指定特定大小。比如使用BitBec(‘a’,32)就可以表示c语言的int型</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h4 id="solver"><a href="#solver" class="headerlink" title="solver()"></a>solver()</h4><p>solver()会创建一个通用求解器，创建后我们可以添加我们的约束条件，进行下一步的求解</p><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p>add()用来添加约束条件，约束条件通常是一个逻辑等式</p><h4 id="check"><a href="#check" class="headerlink" title="check()"></a>check()</h4><p>check()如其名，用于判断，有解会回显sat，无解会回显unsat</p><h4 id="model"><a href="#model" class="headerlink" title="model()"></a>model()</h4><p>model()用于多解集的情况，它会限制条件所对应的解集的交集，得出唯一解</p><blockquote><h5 id="常用求解四步骤："><a href="#常用求解四步骤：" class="headerlink" title="常用求解四步骤："></a>常用求解四步骤：</h5><p>创建约束求解器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solver = Solver()</span><br></pre></td></tr></table></figure><p>添加约束条件（这一步是z3求解的关键）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solver.add()</span><br></pre></td></tr></table></figure><p>判断解是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if solver.check()==sat:</span><br></pre></td></tr></table></figure><p>求解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print solver.model()</span><br></pre></td></tr></table></figure></blockquote><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>感觉难度不是很大，接下来就要从编写脚本中体验了<br>NewStarCTF 2023的逆向R4ndom,通过一个码表加密flag，进行了下面这样一个运算(题解实际还包含一个随机数和一个反调试<a href="https://shimo.im/docs/Dy5ekHJhKo0ap5v3/read">题解</a>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input[i] = Table[(16 * ((tmp + rand_num % 255) &gt;&gt; 4) + 15) &amp; (tmp + rand_num % 255)];</span><br></pre></td></tr></table></figure><p><img src="/images/article/20231107/image-20231107110933.png"><br><a href="https://buuoj.cn/match/matches/190/challenges#%E3%80%90%E5%B7%B2%E5%81%9C%E6%AD%A2%E6%8F%90%E4%BA%A4%E3%80%91R4ndom">题目链接</a></p><p>直接写python也不是不能写，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">table = [</span><br><span class="line">  0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, </span><br><span class="line">  0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, </span><br><span class="line">  0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, </span><br><span class="line">  0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, </span><br><span class="line">  0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, </span><br><span class="line">  0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, </span><br><span class="line">  0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, </span><br><span class="line">  0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, </span><br><span class="line">  0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, </span><br><span class="line">  0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, </span><br><span class="line">  0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, </span><br><span class="line">  0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, </span><br><span class="line">  0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, </span><br><span class="line">  0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, </span><br><span class="line">  0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, </span><br><span class="line">  0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, </span><br><span class="line">  0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, </span><br><span class="line">  0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, </span><br><span class="line">  0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, </span><br><span class="line">  0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, </span><br><span class="line">  0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, </span><br><span class="line">  0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, </span><br><span class="line">  0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, </span><br><span class="line">  0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, </span><br><span class="line">  0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, </span><br><span class="line">  0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16</span><br><span class="line">]</span><br><span class="line">enc = [0xEE, 0xE6, 0xD7, 0xB2, 0x8A, 0xAB, 0x13, 0x35, 0x02, 0x7B, 0xC9, 0xB9, 0x9C, 0xBA, 0xED, 0x2E, 0xBD, 0x4F, 0xFA, 0xEE, 0xC8, 0xF8, 0xE4, 0x16, 0x82, 0x63, 0x3B, 0x98, 0xF4, 0x14, 0x30, 0x38, 0x07, 0x36, 0x84, 0x3D, 0x0C, 0x36, 0x32, 0xEA, 0x55, 0xA6]</span><br><span class="line">rkey = [51,137,172,215,84,204,74,165,53,209,219,163,230,147,15,127,149,77,231,101,128,175,107,210,204,205,20,173,141,105,198,64,242,242,24,71,64,226,108,117,180,72,]</span><br><span class="line">flag = &quot;&quot;</span><br><span class="line"></span><br><span class="line">for j in range(len(enc)):</span><br><span class="line">    for i in range(32, 126):</span><br><span class="line">        i = int(i)</span><br><span class="line">        tmp = table[((16 * ((i + rkey[j] % 255) &gt;&gt; 4) + 15) &amp; (i + rkey[j] % 255)) &amp; 0xff]</span><br><span class="line">        if enc[j] == tmp:</span><br><span class="line">            flag += chr(i)</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>接下来我用z3来求一求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">...</span><br><span class="line"># 这里将索引获取</span><br><span class="line">index = []</span><br><span class="line">for i in enc:</span><br><span class="line">    index.append((table.index(i)))</span><br><span class="line"></span><br><span class="line"># 创建 Z3 求解器</span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line"># 创建符号变量 temp</span><br><span class="line">temp = [BitVec(&#x27;%d&#x27; % i, 8) for i in range(len(enc))]</span><br><span class="line"></span><br><span class="line"># 添加len(enc)个约束条件</span><br><span class="line">for i in range(len(enc)):</span><br><span class="line">    constraint = index[i] == (16 * ((temp[i] + rkey[i] % 255) &gt;&gt; 4) + 15) &amp; (temp[i] + rkey[i] % 255)</span><br><span class="line">    s.add(constraint)</span><br><span class="line"></span><br><span class="line">if s.check() == sat:</span><br><span class="line">    indexult = s.model()</span><br><span class="line">    for i in range(len(enc)):</span><br><span class="line">        flag += chr(indexult[temp[i]].as_long())</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>通过添加很多个约束条件来利用z3求解，效率还是挺高的</p><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><p><a href="https://bbs.kanxue.com/thread-266921.htm#msg_header_h1_1">[原创]Z3求解约束器及例题</a><br><a href="https://tearorca.github.io/z3%E7%BA%A6%E6%9D%9F%E5%99%A8/#z3%E5%AE%89%E8%A3%85">z3约束器</a><br><a href="https://zhuanlan.zhihu.com/p/30548907">Z3一把梭：用约束求解搞定一类CTF题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前遇见简单的逆向题用z3求解器简单求过，但是没有仔细学习过，这次又遇到一道逆向题，听说z3爆破很有作用&lt;/p&gt;
&lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/</summary>
      
    
    
    
    <category term="Re" scheme="https://corsnail.github.io/categories/Re/"/>
    
    
    <category term="z3" scheme="https://corsnail.github.io/tags/z3/"/>
    
  </entry>
  
  <entry>
    <title>leetcode每日一题7.20kandane</title>
    <link href="https://corsnail.github.io/2023/07/20/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%987-20kandane/"/>
    <id>https://corsnail.github.io/2023/07/20/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%987-20kandane/</id>
    <published>2023-07-20T03:20:06.000Z</published>
    <updated>2023-07-20T05:24:44.912Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">https://leetcode.cn/problems/maximum-sum-circular-subarray/</a><br>leetcode今天的题目是一个环形数组求最大和<br><img src="/images/article/20230720/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%987-20kandane/0.png"><br>很明显是一个动态规划，使用kandane算法很简单解决</p><h2 id="kandane算法"><a href="#kandane算法" class="headerlink" title="kandane算法"></a>kandane算法</h2><p>讲解：<a href="https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d">https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d</a><br>这个大佬讲的比较好<br>设数组为a时，<br>当前索引i的最大子数组和等于前索引i-1的最大子数组和加上当前值a[i]<br><img src="/images/article/20230720/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%987-20kandane/1.png"><br>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        int local_max = 0;</span><br><span class="line">        int global_max = INT_MIN;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 2*len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            local_max = max(nums[i%len],nums[i%len] + local_max);</span><br><span class="line">            if (local_max &gt; global_max)</span><br><span class="line">                global_max = local_max;</span><br><span class="line">        &#125;</span><br><span class="line">        return global_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这个问题比起其他题目有所不同，是一个环形数组</p><h2 id="最大子数组有两种情况"><a href="#最大子数组有两种情况" class="headerlink" title="最大子数组有两种情况"></a>最大子数组有两种情况</h2><h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><p>最大子数组和在中间，这时上面的代码就可以直接使用得到最大子数组和<br><img src="/images/article/20230720/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%987-20kandane/2.png"></p><h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><p>最大子数组贯穿头尾<br><img src="/images/article/20230720/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%987-20kandane/3.png"><br>这时就只能计算最小子数组和，然后用总和减去最小的子数组和即可</p><p>最终代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        int local_max = 0;</span><br><span class="line">        int global_max = INT_MIN;</span><br><span class="line">        int total_sum = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            local_max = max(nums[i], nums[i] + local_max);</span><br><span class="line">            global_max = max(local_max, global_max);</span><br><span class="line">            total_sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //对于环形的数组，总和一定，总和减去最小的子数组和就是最大子数组和</span><br><span class="line">        int min_wrap = INT_MAX;</span><br><span class="line">        int current_sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; len; ++i) &#123;</span><br><span class="line">            current_sum = min(nums[i], nums[i] + current_sum);</span><br><span class="line">            min_wrap = min(min_wrap, current_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        int max_wrap = total_sum - min_wrap; // 重新计算 max_wrap</span><br><span class="line"></span><br><span class="line">        if (max_wrap == 0) &#123;</span><br><span class="line">            return global_max;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return max(global_max, max_wrap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.cn/problems/maximum-sum-circular-subarray/&quot;&gt;https://leetcode.cn/problems/maximum-sum-circular-subarray/&lt;/a</summary>
      
    
    
    
    <category term="算法" scheme="https://corsnail.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://corsnail.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>linux可执行文件添加到环境变量</title>
    <link href="https://corsnail.github.io/2023/07/04/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://corsnail.github.io/2023/07/04/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2023-07-04T13:59:28.000Z</published>
    <updated>2023-07-08T06:21:52.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遇见问题"><a href="#遇见问题" class="headerlink" title="遇见问题"></a>遇见问题</h2><p>在使用fscan的过程中，需要把源码下载下来编译，编译之后是一个可执行文件而使用时就需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main -h 192.168.1.133/24</span><br></pre></td></tr></table></figure><p><img src="/images/article/20230704/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/0.png"><br>于是我就想将可执行文件添加到环境变量中</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>打开配置文件，看终端，可能是bashrc，我的是zshrc<br><img src="/images/article/20230704/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/1.png"></li><li>在末尾加入一行，&#x2F;path&#x2F;to&#x2F;fscan是你的fscan目录路径，刚编译好的fscan需要改个名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/path/to/fscan:$PATH</span><br></pre></td></tr></table></figure><img src="/images/article/20230704/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/2.png"></li><li>然后记得更新<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>然后就可以在终端的任何地方使用fscan了<br><img src="/images/article/20230704/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/3.png"></li></ol><p>其实不止这一种方法，添加进不同的位置有不同的作用，可以参考：<br><a href="https://blog.csdn.net/weixin_38870322/article/details/80169531">https://blog.csdn.net/weixin_38870322/article/details/80169531</a></p><p>另外还有个思路，linux会有一个文件夹（&#x2F;bin）专门放可执行文件，linux环境变量会加入这个文件夹的全部变量，输入下面命令可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p><img src="/images/article/20230704/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/4.png"><br>有很多个目录，建议不要打乱它本身的秩序，具体不同分类的区别可以看下面<br><a href="https://blog.csdn.net/lh2016rocky/article/details/70801030">https://blog.csdn.net/lh2016rocky/article/details/70801030</a><br>总结就是：</p><blockquote><p>重要的二进制位于 &#x2F;bin（用户二进制）以及 &#x2F;sbin（系统二进制）中。不重要的二进制（如图形环境或Office 工具）安装在 &#x2F;usr&#x2F;bin 和 &#x2F;usr&#x2F;sbin中。进行这种分隔是为了尽可能地缩小根分区。使用源代码编译的软件通常位于 &#x2F;usr&#x2F;local&#x2F;bin 和 &#x2F;usr&#x2F;local&#x2F;sbin中。</p></blockquote><p>所以这里我们的fscan应该放到&#x2F;usr&#x2F;local&#x2F;bin中，<br>直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /home/kali/fscan/fscan /usr/local/bin</span><br></pre></td></tr></table></figure><p>记得sudo<br><img src="/images/article/20230704/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/5.png"><br>这样去掉环境变量中的fscan目录，也可以使用<br><img src="/images/article/20230704/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;遇见问题&quot;&gt;&lt;a href=&quot;#遇见问题&quot; class=&quot;headerlink&quot; title=&quot;遇见问题&quot;&gt;&lt;/a&gt;遇见问题&lt;/h2&gt;&lt;p&gt;在使用fscan的过程中，需要把源码下载下来编译，编译之后是一个可执行文件而使用时就需要&lt;/p&gt;
&lt;figure class</summary>
      
    
    
    
    <category term="技术分享" scheme="https://corsnail.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="linux" scheme="https://corsnail.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用</title>
    <link href="https://corsnail.github.io/2023/07/04/hexo%E4%BD%BF%E7%94%A8/"/>
    <id>https://corsnail.github.io/2023/07/04/hexo%E4%BD%BF%E7%94%A8/</id>
    <published>2023-07-04T03:07:11.000Z</published>
    <updated>2023-07-04T05:34:05.676Z</updated>
    
    <content type="html"><![CDATA[<p>hexo g  # 生成博客网页文件<br>hexo s  # 本地预览博客<br>hexo d  # 上传网页文件到github</p><p>hexo new post “article title” #新建文章</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo g  # 生成博客网页文件&lt;br&gt;hexo s  # 本地预览博客&lt;br&gt;hexo d  # 上传网页文件到github&lt;/p&gt;
&lt;p&gt;hexo new post “article title” #新建文章&lt;/p&gt;
</summary>
      
    
    
    
    <category term="hexo" scheme="https://corsnail.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://corsnail.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>你好</title>
    <link href="https://corsnail.github.io/2023/06/06/%E4%BD%A0%E5%A5%BD/"/>
    <id>https://corsnail.github.io/2023/06/06/%E4%BD%A0%E5%A5%BD/</id>
    <published>2023-06-06T12:21:35.000Z</published>
    <updated>2023-06-06T12:22:06.053Z</updated>
    
    <content type="html"><![CDATA[<p>hello!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hello!&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
